data Nat where
    zero : Nat
    succ : Nat -> Nat

data List {a:Type} where
    nil : List{a}
    cons : a -> List{a} -> List{a}

lnil := List.nil
lcons := List.cons

(*
    c : List := List.nil
        chk List.nil : List
            [] unify ({{Type}} -> List{0}) List
                [Type] unify (List{0}) List
                unification defer.
            unification successful. implicit: [{{Type}}]
            chk List : Type
                [] unify ({Type} -> Type) Type
                    [Type] unify Type Type
                    unification successful. implicit: []
                unification successful. implicit: [{Type}]
            typechk successful. List {?0:Type} : Type
        typechk successful. List.nil {{?1:Type}} : List {?0:Type}
    c : List {?0:Type} := List.nil {{?1:Type}}
        chk List.nil {{?1:Type}} : List {?0:Type}
            [] unify List{?1} List{?0}
            ?1 = ?0
    c : List {?0:Type} := List.nil {{?0:Type}}
*)

data Option {a:Type} where
    some : a -> Option{a}
    none : Option{a}

some := Option.some
none := Option.none

at {a} (n: Nat) (xs: List{a}) : Option{a} :=
    case xs of
        List.nil y ys => case n of
            Nat.zero => some y,
            Nat.succ k => at k ys
        List.cons => none

(*

map {a} {b} (f: a->b) (xs: List{a}) : List{b} :=
    case xs of
        List.nil => lnil,
        List.cons y ys => lcons (f y) (map f ys)

*)