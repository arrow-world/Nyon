type Set[U] :== U -> Bool

module finite
    type Set[U] :== List[U]
        canon \xs. (lmap meta.numbering xs) |> lunique
    
    card (X:Set) := List.length(raw X)
    singleton? (X:Set) := card(X) = 1
    all [U] (X:Set[U], P:U->Bool) := Set.from lall(raw X, P)
    map [A,B] (f:A->B, X:Set[A]) := Set.from lmap(f, raw X)
    class [U] (X:Set[U], P:U->Bool) := Set.from lfilter(raw X, P)
    
    type BinRel[A,B] :== Set[A*B]

    left R:BinRel := map $ raw R , \(x,y). x
    right R:BinRel := map $ raw R , \(x,y). y
    relate [A,B] (R:BinRel[A,B], a:A) := class (raw R, \(x,y). x = a)

    type PartialMap[A,B] :<= BinRel[A,B]
        where \R. all $ left R $ \x. singleton? (relate R x)