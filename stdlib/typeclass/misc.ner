typeclass Functor f
    fmap : (a -> b) -> f a -> f b
where
    fmap(id) = id
    fmap(f*g) = fmap(f)*fmap(g)

typeclass Applicative f <= Functor f
    pure : a -> f a
    ap : m (a -> b) -> m a -> m b
where
    ?

typeclass Monad m <== Applicative m
    unit : a -> f a
    infix >>= : m a -> (a -> m b) -> m b
where
    (unit x) >>= f   =  f x
    m >>= unit       =  m
    (m >>= f) >>= g  =  m >>= (\x -> f x >>= g)

module state
    type State S T == struct{current_state: S} -> struct{next_state: S, output: T}

    new[S,T](f: S -> S*T) := State (\x ->
        let (next_state, output) := f(x.current_state)
            in {next_state => next_state, output => output}
    )

    run[S,T](st: State S T, s: S) : T*S :=
        let y := *st(s) in (y.next_state, y.output)

    eval[S,T](st: State S T, s: S) : T := 
        let y := *st(s) in y.output
    
    exec[S,T](st: State S T, s: S) : S :=
        let y := *st(s) in y.next_state
    
    impl[S] Monad (State S)
        unit x := State \s -> (x, s)
        (State h) >>= f :=
            \s ->
                let
                    y := h {current_state => s}
                    State g := (f y.result)
                in g y.next_state